<html>
  <head>
    <title>Holo JS</title>
    <style> 
      body {padding: 0; margin: 0; background-color:#000;}
      #viewportUp {
        position:absolute;
        top:0px;
        left:300px;
        width:300px;
        height:300px;
        -webkit-transform: rotate(0deg);
        -moz-transform: rotate(0deg);
        -o-transform: rotate(0deg);
        -ms-transform: rotate(0deg);
        transform: rotate(0deg);
      }
      #viewportLeft {
        position:absolute;
        top:300px;
        left:0px;
        width:300px;
        height:300px;
        -webkit-transform: rotate(270deg);
        -moz-transform: rotate(270deg);
        -o-transform: rotate(270deg);
        -ms-transform: rotate(270deg);
        transform: rotate(270deg);
      }
      #centerpoint {
        position:absolute;
        top:325px;
        left:325px;
        width:250px;
        height:250px;
        background-color:#FFF;
      }
      #viewportRight {
        position:absolute;
        top:300px;
        left:600px;
        width:300px;
        height:300px;
        -webkit-transform: rotate( 90deg);
        -moz-transform: rotate( 90deg);
        -o-transform: rotate( 90deg);
        -ms-transform: rotate( 90deg);
        transform: rotate( 90deg);
      }
      #viewportDown {
        position:absolute;
        top:600px;
        left:300px;
        width:300px;
        height:300px;
        -webkit-transform: rotate(180deg);
        -moz-transform: rotate(180deg);
        -o-transform: rotate(180deg);
        -ms-transform: rotate(180deg);
        transform: rotate(180deg);
      }
      #container {
        width:900px;
        height:900px;
        position: absolute;
        top:0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
      }
      #loader {
        position:fixed;
      }
    </style>
  </head>
  <body>
    <form action="#" id="loader">
      <input type="text" id="filename">
      <input type="submit" onclick="updateModel()" value="Open">
    </form>
    <div id="container">
      <canvas id='viewportUp'></canvas>
      <canvas id='viewportLeft'></canvas>
      <canvas id='centerpoint'></canvas>
      <canvas id='viewportDown'></canvas>
      <canvas id='viewportRight'></canvas>
    </div>
    <script src="../common/js/three.min.js"></script>
    <script src="../common/js/OBJLoader.js"></script>
    <script>
        var upCanvas = document.getElementById("viewportUp")
        var upRenderer = new THREE.WebGLRenderer({ canvas: upCanvas });
        
        var leftCanvas = document.getElementById("viewportLeft")
        var leftRenderer = new THREE.WebGLRenderer({ canvas: leftCanvas });
        
        var downCanvas = document.getElementById("viewportDown")
        var downRenderer = new THREE.WebGLRenderer({ canvas: downCanvas });
        
        var rightCanvas = document.getElementById("viewportRight")
        var rightRenderer = new THREE.WebGLRenderer({ canvas: rightCanvas });
        
        var manager = new THREE.LoadingManager();
        var lights = [];
        lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
        lights[ 1 ] = new THREE.PointLight( 0xffffff, 1, 0 );
        lights[ 2 ] = new THREE.PointLight( 0xffffff, 1, 0 );
        
        lights[ 0 ].position.set( 0, 200, 0 );
        lights[ 1 ].position.set( 100, 200, 100 );
        lights[ 2 ].position.set( - 100, - 200, - 100 );
        
        manager.onProgress = function ( item, loaded, total ) {};
        mtobj = null;
        function render ( renderer ) {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera( 45, 1, 0.1, 1000 );
            material = new THREE.MeshStandardMaterial( { color: 0x00ffff } );
        
            renderer.setSize(300, 300);
            camera.position.z = 2.0;
            update(renderer, mtobj);
        }
        function update(renderer) {
            requestAnimationFrame( function() {
                update(renderer);
            } );
        
            renderer.clear()
            for (let i = scene.children.length - 1; i >= 0 ; i--) {
                let child = scene.children[ i ];
                scene.remove(child);
            }
            scene.add( lights[ 0 ] );
            scene.add( lights[ 1 ] );
            scene.add( lights[ 2 ] );
        
            if(mtobj) {
                mtobj.rotation.z += 0.005;
                scene.add(mtobj);
            }
            renderer.render(scene, camera);
        };
        function loadObject(objfile) {
            mtobj = null;
            var loader = new THREE.OBJLoader( manager );
            loader.load( objfile, function ( obj ) { 
                obj.traverse(function (child) {
                    if (child instanceof THREE.Mesh) {
                        child.material = material;
                    }
                });
                mtobj = obj;
                mtobj.rotation.x = -Math.PI/2;
                mtobj.position.y -= 0.5;
                mtobj.position.z = 0;
            });
        }
        loadObject("../common/obj/bb8.obj");
        render(upRenderer);
        render(leftRenderer);
        render(downRenderer);
        render(rightRenderer);
        
        function updateModel() {
            loadObject("../common/obj/"+document.getElementById("filename").value)
        }
    </script>
  </body>
</html>
